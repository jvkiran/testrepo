/* eslint-disable */

THREE.SpriteCanvasMaterial = function (e) { THREE.Material.call(this), this.type = "SpriteCanvasMaterial", this.color = new THREE.Color(16777215), this.program = function () { }, this.setValues(e) }, THREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteCanvasMaterial.prototype.constructor = THREE.SpriteCanvasMaterial, THREE.SpriteCanvasMaterial.prototype.isSpriteCanvasMaterial = !0, THREE.SpriteCanvasMaterial.prototype.clone = function () { var e = new THREE.SpriteCanvasMaterial; return e.copy(this), e.color.copy(this.color), e.program = this.program, e }, THREE.CanvasRenderer = function (e) { function t(e, t, i) { for (var r = 0, o = y.length; r < o; r++) { var n = y[r]; if (se.copy(n.color), n.isDirectionalLight) { a = Ee.setFromMatrixPosition(n.matrixWorld).normalize(); if ((s = t.dot(a)) <= 0) continue; s *= n.intensity, i.add(se.multiplyScalar(s)) } else if (n.isPointLight) { var a = Ee.setFromMatrixPosition(n.matrixWorld), s = t.dot(Ee.subVectors(a, e).normalize()); if (s <= 0) continue; if (0 == (s *= 0 == n.distance ? 1 : 1 - Math.min(e.distanceTo(a) / n.distance, 1))) continue; s *= n.intensity, i.add(se.multiplyScalar(s)) } } } function i(e, i, n, s, p, d, f, h) { if (V.info.render.vertices += 3, V.info.render.faces++ , l(h.opacity), c(h.blending), R = e.positionScreen.x, T = e.positionScreen.y, w = i.positionScreen.x, M = i.positionScreen.y, C = n.positionScreen.x, H = n.positionScreen.y, function (e, t, i, r, o, n) { K.beginPath(), K.moveTo(e, t), K.lineTo(i, r), K.lineTo(o, n), K.closePath() }(R, T, w, M, C, H), (h.isMeshLambertMaterial || h.isMeshPhongMaterial || h.isMeshStandardMaterial) && null === h.map) ne.copy(h.color), ae.copy(h.emissive), h.vertexColors === THREE.FaceColors && ne.multiply(f.color), oe.copy(fe), ve.copy(e.positionWorld).add(i.positionWorld).add(n.positionWorld).divideScalar(3), t(ve, f.normalModel, oe), oe.multiply(ne).add(ae), !0 === h.wireframe ? r(oe, h.wireframeLinewidth, h.wireframeLinecap, h.wireframeLinejoin) : o(oe); else if (h.isMeshBasicMaterial || h.isMeshLambertMaterial || h.isMeshPhongMaterial || h.isMeshStandardMaterial) if (null !== h.map) { h.map.mapping === THREE.UVMapping && (b = f.uvs, a(R, T, w, M, C, H, b[s].x, b[s].y, b[p].x, b[p].y, b[d].x, b[d].y, h.map)) } else null !== h.envMap ? h.envMap.mapping === THREE.SphericalReflectionMapping && (xe.copy(f.vertexNormalsModel[s]).applyMatrix3(ye), L = .5 * xe.x + .5, B = .5 * xe.y + .5, xe.copy(f.vertexNormalsModel[p]).applyMatrix3(ye), P = .5 * xe.x + .5, z = .5 * xe.y + .5, xe.copy(f.vertexNormalsModel[d]).applyMatrix3(ye), W = .5 * xe.x + .5, j = .5 * xe.y + .5, a(R, T, w, M, C, H, L, B, P, z, W, j, h.envMap)) : (oe.copy(h.color), h.vertexColors === THREE.FaceColors && oe.multiply(f.color), !0 === h.wireframe ? r(oe, h.wireframeLinewidth, h.wireframeLinecap, h.wireframeLinejoin) : o(oe)); else h.isMeshNormalMaterial ? (xe.copy(f.normalModel).applyMatrix3(ye), oe.setRGB(xe.x, xe.y, xe.z).multiplyScalar(.5).addScalar(.5), !0 === h.wireframe ? r(oe, h.wireframeLinewidth, h.wireframeLinecap, h.wireframeLinejoin) : o(oe)) : (oe.setRGB(1, 1, 1), !0 === h.wireframe ? r(oe, h.wireframeLinewidth, h.wireframeLinecap, h.wireframeLinejoin) : o(oe)) } function r(e, t, i, r) { p(t), d(i), f(r), h(e.getStyle()), K.stroke(), de.expandByScalar(2 * t) } function o(e) { m(e.getStyle()), K.fill() } function n(e) { if (0 === e.version || e instanceof THREE.CompressedTexture || e instanceof THREE.DataTexture) return { canvas: void 0, version: e.version }; var t = e.image; if (!1 === t.complete) return { canvas: void 0, version: 0 }; var i = e.wrapS === THREE.RepeatWrapping || e.wrapS === THREE.MirroredRepeatWrapping, r = e.wrapT === THREE.RepeatWrapping || e.wrapT === THREE.MirroredRepeatWrapping, o = e.wrapS === THREE.MirroredRepeatWrapping, n = e.wrapT === THREE.MirroredRepeatWrapping, a = document.createElement("canvas"); a.width = t.width * (o ? 2 : 1), a.height = t.height * (n ? 2 : 1); var s = a.getContext("2d"); s.setTransform(1, 0, 0, -1, 0, t.height), s.drawImage(t, 0, 0), !0 === o && (s.setTransform(-1, 0, 0, -1, t.width, t.height), s.drawImage(t, -t.width, 0)), !0 === n && (s.setTransform(1, 0, 0, 1, 0, 0), s.drawImage(t, 0, t.height)), !0 === o && !0 === n && (s.setTransform(-1, 0, 0, 1, t.width, 0), s.drawImage(t, -t.width, t.height)); var l = "no-repeat"; !0 === i && !0 === r ? l = "repeat" : !0 === i ? l = "repeat-x" : !0 === r && (l = "repeat-y"); var c = K.createPattern(a, l); return e.onUpdate && e.onUpdate(e), { canvas: c, version: e.version } } function a(e, t, i, r, o, a, s, l, c, p, d, f, h) { var E = le[h.id]; if (void 0 !== E && E.version === h.version || (E = n(h), le[h.id] = E), void 0 === E.canvas) return m("rgba( 0, 0, 0, 1)"), void K.fill(); m(E.canvas); var v, x, y, u, g, S, R, T, w = h.offset.x / h.repeat.x, M = h.offset.y / h.repeat.y, C = h.image.width * h.repeat.x, H = h.image.height * h.repeat.y; c = (c + w) * C, p = (p + M) * H, d = (d + w) * C, f = (f + M) * H, i -= e, r -= t, o -= e, a -= t, 0 !== (R = (c -= s = (s + w) * C) * (f -= l = (l + M) * H) - (d -= s) * (p -= l)) && (g = e - (v = (f * i - p * o) * (T = 1 / R)) * s - (y = (c * o - d * i) * T) * l, S = t - (x = (f * r - p * a) * T) * s - (u = (c * a - d * r) * T) * l, K.save(), K.transform(v, x, y, u, g, S), K.fill(), K.restore()) } function s(e, t, i) { var r, o = t.x - e.x, n = t.y - e.y, a = o * o + n * n; 0 !== a && (o *= r = i / Math.sqrt(a), n *= r, t.x += o, t.y += n, e.x -= o, e.y -= n) } function l(e) { Y !== e && (K.globalAlpha = e, Y = e) } function c(e) { Z !== e && (e === THREE.NormalBlending ? K.globalCompositeOperation = "source-over" : e === THREE.AdditiveBlending ? K.globalCompositeOperation = "lighter" : e === THREE.SubtractiveBlending ? K.globalCompositeOperation = "darker" : e === THREE.MultiplyBlending && (K.globalCompositeOperation = "multiply"), Z = e) } function p(e) { ee !== e && (K.lineWidth = e, ee = e) } function d(e) { te !== e && (K.lineCap = e, te = e) } function f(e) { ie !== e && (K.lineJoin = e, ie = e) } function h(e) { $ !== e && (K.strokeStyle = e, $ = e) } function m(e) { _ !== e && (K.fillStyle = e, _ = e) } function E(e) { re.length !== e.length && (K.setLineDash(e), re = e) } e = e || {}; var v, x, y, u, g, S, R, T, w, M, C, H, b, L, B, P, z, W, j, V = this, D = new THREE.Projector, F = void 0 !== e.canvas ? e.canvas : document.createElement("canvas"), N = F.width, k = F.height, A = Math.floor(N / 2), O = Math.floor(k / 2), G = 0, I = 0, U = N, q = k, J = 1, K = F.getContext("2d", { alpha: !0 === e.alpha }), Q = new THREE.Color(0), X = !0 === e.alpha ? 0 : 1, Y = 1, Z = 0, $ = null, _ = null, ee = null, te = null, ie = null, re = [], oe = new THREE.Color, ne = new THREE.Color, ae = new THREE.Color, se = new THREE.Color, le = {}, ce = new THREE.Box2, pe = new THREE.Box2, de = new THREE.Box2, fe = new THREE.Color, he = new THREE.Color, me = new THREE.Color, Ee = new THREE.Vector3, ve = new THREE.Vector3, xe = new THREE.Vector3, ye = new THREE.Matrix3; void 0 === K.setLineDash && (K.setLineDash = function () { }), this.domElement = F, this.autoClear = !0, this.sortObjects = !0, this.sortElements = !0, this.info = { render: { vertices: 0, faces: 0 } }, this.supportsVertexTextures = function () { }, this.setFaceCulling = function () { }, this.getContext = function () { return K }, this.getContextAttributes = function () { return K.getContextAttributes() }, this.getPixelRatio = function () { return J }, this.setPixelRatio = function (e) { void 0 !== e && (J = e) }, this.setSize = function (e, t, i) { N = e * J, k = t * J, F.width = N, F.height = k, A = Math.floor(N / 2), O = Math.floor(k / 2), !1 !== i && (F.style.width = e + "px", F.style.height = t + "px"), ce.min.set(-A, -O), ce.max.set(A, O), pe.min.set(-A, -O), pe.max.set(A, O), Y = 1, Z = 0, $ = null, _ = null, ee = null, te = null, ie = null, this.setViewport(0, 0, e, t) }, this.setViewport = function (e, t, i, r) { G = e * J, I = t * J, U = i * J, q = r * J }, this.setScissor = function () { }, this.setScissorTest = function () { }, this.setClearColor = function (e, t) { Q.set(e), X = void 0 !== t ? t : 1, pe.min.set(-A, -O), pe.max.set(A, O) }, this.setClearColorHex = function (e, t) { console.warn("THREE.CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, t) }, this.getClearColor = function () { return Q }, this.getClearAlpha = function () { return X }, this.getMaxAnisotropy = function () { return 0 }, this.clear = function () { !1 === pe.isEmpty() && (pe.intersect(ce), pe.expandByScalar(2), pe.min.x = pe.min.x + A, pe.min.y = -pe.min.y + O, pe.max.x = pe.max.x + A, pe.max.y = -pe.max.y + O, X < 1 && K.clearRect(0 | pe.min.x, 0 | pe.max.y, pe.max.x - pe.min.x | 0, pe.min.y - pe.max.y | 0), X > 0 && (l(1), c(THREE.NormalBlending), m("rgba(" + Math.floor(255 * Q.r) + "," + Math.floor(255 * Q.g) + "," + Math.floor(255 * Q.b) + "," + X + ")"), K.fillRect(0 | pe.min.x, 0 | pe.max.y, pe.max.x - pe.min.x | 0, pe.min.y - pe.max.y | 0)), pe.makeEmpty()) }, this.clearColor = function () { }, this.clearDepth = function () { }, this.clearStencil = function () { }, this.render = function (e, t) { if (void 0 !== t.isCamera) { var r = e.background; r && r.isColor ? (l(1), c(THREE.NormalBlending), m(r.getStyle()), K.fillRect(0, 0, N, k)) : !0 === this.autoClear && this.clear(), V.info.render.vertices = 0, V.info.render.faces = 0, K.setTransform(U / N, 0, 0, -q / k, G, k - I), K.translate(A, O), v = D.projectScene(e, t, this.sortObjects, this.sortElements), x = v.elements, y = v.lights, ye.getNormalMatrix(t.matrixWorldInverse), function () { fe.setRGB(0, 0, 0), he.setRGB(0, 0, 0), me.setRGB(0, 0, 0); for (var e = 0, t = y.length; e < t; e++) { var i = y[e], r = i.color; i.isAmbientLight ? fe.add(r) : i.isDirectionalLight ? he.add(r) : i.isPointLight && me.add(r) } }(); for (var o = 0, a = x.length; o < a; o++) { var R = x[o], T = R.material; if (void 0 !== T && 0 !== T.opacity) { if (de.makeEmpty(), R instanceof THREE.RenderableSprite) (u = R).x *= A, u.y *= O, function (e, t, i) { l(i.opacity), c(i.blending); var r = t.scale.x * A, o = t.scale.y * O, a = Math.sqrt(r * r + o * o); if (de.min.set(e.x - a, e.y - a), de.max.set(e.x + a, e.y + a), i.isSpriteMaterial) { var s = i.map; if (null !== s) { var p = le[s.id]; if (void 0 !== p && p.version === s.version || (p = n(s), le[s.id] = p), void 0 !== p.canvas) { m(p.canvas); var d = s.image, f = d.width * s.offset.x, E = d.height * s.offset.y, v = d.width * s.repeat.x, x = d.height * s.repeat.y, y = r / v, u = o / x; K.save(), K.translate(e.x, e.y), 0 !== i.rotation && K.rotate(i.rotation), K.translate(-r / 2, -o / 2), K.scale(y, u), K.translate(-f, -E), K.fillRect(f, E, v, x), K.restore() } } else m(i.color.getStyle()), K.save(), K.translate(e.x, e.y), 0 !== i.rotation && K.rotate(i.rotation), K.scale(r, -o), K.fillRect(-.5, -.5, 1, 1), K.restore() } else i.isSpriteCanvasMaterial ? (h(i.color.getStyle()), m(i.color.getStyle()), K.save(), K.translate(e.x, e.y), 0 !== i.rotation && K.rotate(i.rotation), K.scale(r, o), i.program(K), K.restore()) : i.isPointsMaterial && (m(i.color.getStyle()), K.save(), K.translate(e.x, e.y), 0 !== i.rotation && K.rotate(i.rotation), K.scale(r * i.size, -o * i.size), K.fillRect(-.5, -.5, 1, 1), K.restore()) }(u, R, T); else if (R instanceof THREE.RenderableLine) u = R.v1, g = R.v2, u.positionScreen.x *= A, u.positionScreen.y *= O, g.positionScreen.x *= A, g.positionScreen.y *= O, de.setFromPoints([u.positionScreen, g.positionScreen]), !0 === ce.intersectsBox(de) && function (e, t, i, r) { if (l(r.opacity), c(r.blending), K.beginPath(), K.moveTo(e.positionScreen.x, e.positionScreen.y), K.lineTo(t.positionScreen.x, t.positionScreen.y), r.isLineBasicMaterial) { if (p(r.linewidth), d(r.linecap), f(r.linejoin), r.vertexColors !== THREE.VertexColors) h(r.color.getStyle()); else { var o = i.vertexColors[0].getStyle(), n = i.vertexColors[1].getStyle(); if (o === n) h(o); else { try { var a = K.createLinearGradient(e.positionScreen.x, e.positionScreen.y, t.positionScreen.x, t.positionScreen.y); a.addColorStop(0, o), a.addColorStop(1, n) } catch (e) { a = o } h(a) } } r.isLineDashedMaterial && E([r.dashSize, r.gapSize]), K.stroke(), de.expandByScalar(2 * r.linewidth), r.isLineDashedMaterial && E([]) } }(u, g, R, T); else if (R instanceof THREE.RenderableFace) { if (u = R.v1, g = R.v2, S = R.v3, u.positionScreen.z < -1 || u.positionScreen.z > 1) continue; if (g.positionScreen.z < -1 || g.positionScreen.z > 1) continue; if (S.positionScreen.z < -1 || S.positionScreen.z > 1) continue; u.positionScreen.x *= A, u.positionScreen.y *= O, g.positionScreen.x *= A, g.positionScreen.y *= O, S.positionScreen.x *= A, S.positionScreen.y *= O, T.overdraw > 0 && (s(u.positionScreen, g.positionScreen, T.overdraw), s(g.positionScreen, S.positionScreen, T.overdraw), s(S.positionScreen, u.positionScreen, T.overdraw)), de.setFromPoints([u.positionScreen, g.positionScreen, S.positionScreen]), !0 === ce.intersectsBox(de) && i(u, g, S, 0, 1, 2, R, T) } pe.union(de) } } K.setTransform(1, 0, 0, 1, 0, 0) } else console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.") } };
