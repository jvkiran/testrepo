/* eslint-disable */

THREE.RenderableObject = function () { this.id = 0, this.object = null, this.z = 0, this.renderOrder = 0 }, THREE.RenderableFace = function () { this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.v3 = new THREE.RenderableVertex, this.normalModel = new THREE.Vector3, this.vertexNormalsModel = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3], this.vertexNormalsLength = 0, this.color = new THREE.Color, this.material = null, this.uvs = [new THREE.Vector2, new THREE.Vector2, new THREE.Vector2], this.z = 0, this.renderOrder = 0 }, THREE.RenderableVertex = function () { this.position = new THREE.Vector3, this.positionWorld = new THREE.Vector3, this.positionScreen = new THREE.Vector4, this.visible = !0 }, THREE.RenderableVertex.prototype.copy = function (e) { this.positionWorld.copy(e.positionWorld), this.positionScreen.copy(e.positionScreen) }, THREE.RenderableLine = function () { this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.vertexColors = [new THREE.Color, new THREE.Color], this.material = null, this.z = 0, this.renderOrder = 0 }, THREE.RenderableSprite = function () { this.id = 0, this.object = null, this.x = 0, this.y = 0, this.z = 0, this.rotation = 0, this.scale = new THREE.Vector2, this.material = null, this.renderOrder = 0 }, THREE.Projector = function () { function e(t) { if (!1 !== t.visible) { if (t instanceof THREE.Light) V.lights.push(t); else if (t instanceof THREE.Mesh || t instanceof THREE.Line || t instanceof THREE.Points) { if (!1 === t.material.visible) return; if (!0 === t.frustumCulled && !1 === F.intersectsObject(t)) return; r(t) } else if (t instanceof THREE.Sprite) { if (!1 === t.material.visible) return; if (!0 === t.frustumCulled && !1 === F.intersectsSprite(t)) return; r(t) } for (var i = t.children, n = 0, o = i.length; n < o; n++)e(i[n]) } } function r(e) { (l = function () { if (c === R) { var e = new THREE.RenderableObject; return x.push(e), R++ , c++ , e } return x[c++] }()).id = e.id, l.object = e, j.setFromMatrixPosition(e.matrixWorld), j.applyMatrix4(N), l.z = j.z, l.renderOrder = e.renderOrder, V.objects.push(l) } function t(e, r, t) { var i = 1 / e.w; e.z *= i, e.z >= -1 && e.z <= 1 && ((v = function () { if (m === z) { var e = new THREE.RenderableSprite; return b.push(e), z++ , m++ , e } return b[m++] }()).id = r.id, v.x = e.x * i, v.y = e.y * i, v.z = e.z, v.renderOrder = r.renderOrder, v.object = r, v.rotation = r.rotation, v.scale.x = r.scale.x * Math.abs(v.x - (e.x + t.projectionMatrix.elements[0]) / (e.w + t.projectionMatrix.elements[12])), v.scale.y = r.scale.y * Math.abs(v.y - (e.y + t.projectionMatrix.elements[5]) / (e.w + t.projectionMatrix.elements[13])), v.material = r.material, V.elements.push(v)) } function i() { if (E === H) { var e = new THREE.RenderableVertex; return T.push(e), H++ , E++ , e } return T[E++] } function n() { if (f === w) { var e = new THREE.RenderableFace; return g.push(e), w++ , f++ , e } return g[f++] } function o() { if (d === M) { var e = new THREE.RenderableLine; return S.push(e), M++ , d++ , e } return S[d++] } function a(e, r) { return e.renderOrder !== r.renderOrder ? e.renderOrder - r.renderOrder : e.z !== r.z ? r.z - e.z : e.id !== r.id ? e.id - r.id : 0 } function s(e, r) { var t = 0, i = 1, n = e.z + e.w, o = r.z + r.w, a = -e.z + e.w, s = -r.z + r.w; return n >= 0 && o >= 0 && a >= 0 && s >= 0 || !(n < 0 && o < 0 || a < 0 && s < 0) && (n < 0 ? t = Math.max(t, n / (n - o)) : o < 0 && (i = Math.min(i, n / (n - o))), a < 0 ? t = Math.max(t, a / (a - s)) : s < 0 && (i = Math.min(i, a / (a - s))), !(i < t) && (e.lerp(r, t), r.lerp(e, 1 - i), !0)) } var l, c, p, E, u, f, h, d, v, m, y, x = [], R = 0, T = [], H = 0, g = [], w = 0, S = [], M = 0, b = [], z = 0, V = { objects: [], lights: [], elements: [] }, j = new THREE.Vector3, O = new THREE.Vector4, C = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)), L = new THREE.Box3, k = new Array(3), B = new THREE.Matrix4, N = new THREE.Matrix4, W = new THREE.Matrix4, A = new THREE.Matrix3, F = new THREE.Frustum, P = new THREE.Vector4, G = new THREE.Vector4; this.projectVector = function (e, r) { console.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(r) }, this.unprojectVector = function (e, r) { console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(r) }, this.pickingRay = function () { console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().") }; var D = new function () { function e(e) { var r = e.position, t = e.positionWorld, i = e.positionScreen; t.copy(r).applyMatrix4(y), i.copy(t).applyMatrix4(N); var n = 1 / i.w; i.x *= n, i.y *= n, i.z *= n, e.visible = i.x >= -1 && i.x <= 1 && i.y >= -1 && i.y <= 1 && i.z >= -1 && i.z <= 1 } function r(e, r, t) { return !0 === e.visible || !0 === r.visible || !0 === t.visible || (k[0] = e.positionScreen, k[1] = r.positionScreen, k[2] = t.positionScreen, C.intersectsBox(L.setFromPoints(k))) } function t(e, r, t) { return (t.positionScreen.x - e.positionScreen.x) * (r.positionScreen.y - e.positionScreen.y) - (t.positionScreen.y - e.positionScreen.y) * (r.positionScreen.x - e.positionScreen.x) < 0 } var a = [], l = [], c = [], E = null, f = null, d = new THREE.Matrix3; return { setObject: function (e) { f = (E = e).material, d.getNormalMatrix(E.matrixWorld), a.length = 0, l.length = 0, c.length = 0 }, projectVertex: e, checkTriangleVisibility: r, checkBackfaceCulling: t, pushVertex: function (r, t, n) { (p = i()).position.set(r, t, n), e(p) }, pushNormal: function (e, r, t) { a.push(e, r, t) }, pushColor: function (e, r, t) { l.push(e, r, t) }, pushUv: function (e, r) { c.push(e, r) }, pushLine: function (e, r) { var t = T[e], i = T[r]; t.positionScreen.copy(t.position).applyMatrix4(W), i.positionScreen.copy(i.position).applyMatrix4(W), !0 === s(t.positionScreen, i.positionScreen) && (t.positionScreen.multiplyScalar(1 / t.positionScreen.w), i.positionScreen.multiplyScalar(1 / i.positionScreen.w), (h = o()).id = E.id, h.v1.copy(t), h.v2.copy(i), h.z = Math.max(t.positionScreen.z, i.positionScreen.z), h.renderOrder = E.renderOrder, h.material = E.material, E.material.vertexColors === THREE.VertexColors && (h.vertexColors[0].fromArray(l, 3 * e), h.vertexColors[1].fromArray(l, 3 * r)), V.elements.push(h)) }, pushTriangle: function (e, i, o) { var s = T[e], l = T[i], p = T[o]; if (!1 !== r(s, l, p) && (f.side === THREE.DoubleSide || !0 === t(s, l, p))) { (u = n()).id = E.id, u.v1.copy(s), u.v2.copy(l), u.v3.copy(p), u.z = (s.positionScreen.z + l.positionScreen.z + p.positionScreen.z) / 3, u.renderOrder = E.renderOrder, u.normalModel.fromArray(a, 3 * e), u.normalModel.applyMatrix3(d).normalize(); for (var h = 0; h < 3; h++) { var v = u.vertexNormalsModel[h]; v.fromArray(a, 3 * arguments[h]), v.applyMatrix3(d).normalize(), u.uvs[h].fromArray(c, 2 * arguments[h]) } u.vertexNormalsLength = 3, u.material = E.material, V.elements.push(u) } } } }; this.projectScene = function (r, l, p, v) { f = 0, d = 0, m = 0, V.elements.length = 0, !0 === r.autoUpdate && r.updateMatrixWorld(), null === l.parent && l.updateMatrixWorld(), B.copy(l.matrixWorldInverse), N.multiplyMatrices(l.projectionMatrix, B), F.setFromMatrix(N), c = 0, V.objects.length = 0, V.lights.length = 0, e(r), !0 === p && V.objects.sort(a); for (var x = V.objects, R = 0, H = x.length; R < H; R++) { var g = x[R].object, w = g.geometry; if (D.setObject(g), y = g.matrixWorld, E = 0, g instanceof THREE.Mesh) { if (w instanceof THREE.BufferGeometry) { var S = w.attributes, M = w.groups; if (void 0 === S.position) continue; for (var b = 0, z = (Te = S.position.array).length; b < z; b += 3)D.pushVertex(Te[b], Te[b + 1], Te[b + 2]); if (void 0 !== S.normal) for (var C = S.normal.array, b = 0, z = C.length; b < z; b += 3)D.pushNormal(C[b], C[b + 1], C[b + 2]); if (void 0 !== S.uv) for (var L = S.uv.array, b = 0, z = L.length; b < z; b += 2)D.pushUv(L[b], L[b + 1]); if (null !== w.index) { ye = w.index.array; if (M.length > 0) for (var k = 0; k < M.length; k++)for (var U = M[k], b = U.start, z = U.start + U.count; b < z; b += 3)D.pushTriangle(ye[b], ye[b + 1], ye[b + 2]); else for (var b = 0, z = ye.length; b < z; b += 3)D.pushTriangle(ye[b], ye[b + 1], ye[b + 2]) } else for (var b = 0, z = Te.length / 3; b < z; b += 3)D.pushTriangle(b, b + 1, b + 2) } else if (w instanceof THREE.Geometry) { var I = w.vertices, q = w.faces, J = w.faceVertexUvs[0]; A.getNormalMatrix(y); for (var K = g.material, Q = Array.isArray(K), X = 0, Y = I.length; X < Y; X++) { Re = I[X]; if (j.copy(Re), !0 === K.morphTargets) for (var Z = w.morphTargets, $ = g.morphTargetInfluences, _ = 0, ee = Z.length; _ < ee; _++) { var re = $[_]; if (0 !== re) { var te = Z[_].vertices[X]; j.x += (te.x - Re.x) * re, j.y += (te.y - Re.y) * re, j.z += (te.z - Re.z) * re } } D.pushVertex(j.x, j.y, j.z) } for (var ie = 0, ne = q.length; ie < ne; ie++) { var oe = q[ie]; if (void 0 !== (K = !0 === Q ? g.material[oe.materialIndex] : g.material)) { var ae = K.side, se = T[oe.a], le = T[oe.b], ce = T[oe.c]; if (!1 !== D.checkTriangleVisibility(se, le, ce)) { var pe = D.checkBackfaceCulling(se, le, ce); if (ae !== THREE.DoubleSide) { if (ae === THREE.FrontSide && !1 === pe) continue; if (ae === THREE.BackSide && !0 === pe) continue } (u = n()).id = g.id, u.v1.copy(se), u.v2.copy(le), u.v3.copy(ce), u.normalModel.copy(oe.normal), !1 !== pe || ae !== THREE.BackSide && ae !== THREE.DoubleSide || u.normalModel.negate(), u.normalModel.applyMatrix3(A).normalize(); for (var Ee = oe.vertexNormals, ue = 0, fe = Math.min(Ee.length, 3); ue < fe; ue++) { var he = u.vertexNormalsModel[ue]; he.copy(Ee[ue]), !1 !== pe || ae !== THREE.BackSide && ae !== THREE.DoubleSide || he.negate(), he.applyMatrix3(A).normalize() } u.vertexNormalsLength = Ee.length; var de = J[ie]; if (void 0 !== de) for (var ve = 0; ve < 3; ve++)u.uvs[ve].copy(de[ve]); u.color = oe.color, u.material = K, u.z = (se.positionScreen.z + le.positionScreen.z + ce.positionScreen.z) / 3, u.renderOrder = g.renderOrder, V.elements.push(u) } } } } } else if (g instanceof THREE.Line) { if (W.multiplyMatrices(N, y), w instanceof THREE.BufferGeometry) { if (void 0 !== (S = w.attributes).position) { for (var b = 0, z = (Te = S.position.array).length; b < z; b += 3)D.pushVertex(Te[b], Te[b + 1], Te[b + 2]); if (void 0 !== S.color) for (var me = S.color.array, b = 0, z = me.length; b < z; b += 3)D.pushColor(me[b], me[b + 1], me[b + 2]); if (null !== w.index) for (var ye, b = 0, z = (ye = w.index.array).length; b < z; b += 2)D.pushLine(ye[b], ye[b + 1]); else for (var xe = g instanceof THREE.LineSegments ? 2 : 1, b = 0, z = Te.length / 3 - 1; b < z; b += xe)D.pushLine(b, b + 1) } } else if (w instanceof THREE.Geometry) { if (0 === (I = g.geometry.vertices).length) continue; (se = i()).positionScreen.copy(I[0]).applyMatrix4(W); for (var xe = g instanceof THREE.LineSegments ? 2 : 1, X = 1, Y = I.length; X < Y; X++)(se = i()).positionScreen.copy(I[X]).applyMatrix4(W), (X + 1) % xe > 0 || (le = T[E - 2], P.copy(se.positionScreen), G.copy(le.positionScreen), !0 === s(P, G) && (P.multiplyScalar(1 / P.w), G.multiplyScalar(1 / G.w), (h = o()).id = g.id, h.v1.positionScreen.copy(P), h.v2.positionScreen.copy(G), h.z = Math.max(P.z, G.z), h.renderOrder = g.renderOrder, h.material = g.material, g.material.vertexColors === THREE.VertexColors && (h.vertexColors[0].copy(g.geometry.colors[X]), h.vertexColors[1].copy(g.geometry.colors[X - 1])), V.elements.push(h))) } } else if (g instanceof THREE.Points) { if (W.multiplyMatrices(N, y), w instanceof THREE.Geometry) for (var X = 0, Y = (I = g.geometry.vertices).length; X < Y; X++) { var Re = I[X]; O.set(Re.x, Re.y, Re.z, 1), O.applyMatrix4(W), t(O, g, l) } else if (w instanceof THREE.BufferGeometry) { if (void 0 !== (S = w.attributes).position) for (var Te = S.position.array, b = 0, z = Te.length; b < z; b += 3)O.set(Te[b], Te[b + 1], Te[b + 2], 1), O.applyMatrix4(W), t(O, g, l) } } else g instanceof THREE.Sprite && (O.set(y.elements[12], y.elements[13], y.elements[14], 1), O.applyMatrix4(N), t(O, g, l)) } return !0 === v && V.elements.sort(a), V } };
